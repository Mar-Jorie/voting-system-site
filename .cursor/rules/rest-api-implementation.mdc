---
description: Implement secure CRUD operations with error handling, authentication, and resilience strategies for Innque API integration.
globs:
alwaysApply: false
---

# REST API Implementation

## ⚠️ AUTHORITATIVE SOURCE FOR AUTHENTICATION & SESSION MANAGEMENT

**This is the ONLY authoritative source for login, authentication, and session implementation. All other files should reference this file for authentication details.**

## 📋 Quick Reference - Key Implementation Sections

- **🔐 Complete Login Implementation**: See "Complete Login & Session Implementation" section
- **🔑 JWT Token Management**: See "Session Implementation" section  
- **🔒 MD5 Password Hashing**: See "Password Hashing with Schema Transform" section
- **🌐 API Client Setup**: See "API Client Implementation" section
- **⚠️ Common Issues & Fixes**: See "Troubleshooting" section

## Objective

Guide REST API implementation through **generic, reusable React hooks** that eliminate redundancy and enable creative adaptation. Focus on **pattern recognition** and **purpose-driven design** rather than creating domain-specific implementations.

---

## 🧩 Core Principles

### Generic Over Specific

- **Use generic hooks** (e.g., `useCreateObject`) instead of domain-specific ones (e.g., `useCreateProduct`)
- **Adapt existing patterns** rather than creating new implementations
- **Recognize common operations** across different domains and reuse them

### Data Operations

- Implement CRUD operations for collections
- Handle complex querying with filtering, pagination, and sorting
- Manage file uploads and downloads
- Coordinate schema management and validation

### Security & Authentication

- Implement JWT-based authentication flows
- Manage secure cookie storage and token lifecycle
- Handle user registration, login, and logout
- Ensure proper authorization headers and access control

#### Auto App ID Configuration (MANDATORY)

**Dynamic App ID Configuration**: Automatically configure the application ID in api.js based on user-provided App ID, replacing the placeholder "your-application-id" with the actual application ID while preserving environment variable fallback.

**App ID Configuration Pattern:**
```javascript
// api.js - App ID configuration
const APP_ID = import.meta.env.VITE_APP_ID || "fallback-app-id";
```

**Auto-Configuration Process:**
When user provides an App ID:
1. **Replace Placeholder**: Update "your-application-id" with the user-provided App ID
2. **Preserve Environment Variable**: Keep `import.meta.env.VITE_APP_ID` as the primary source
3. **Update Fallback**: Change the fallback from "your-application-id" to the actual App ID
4. **Create/Update .env**: Add `VITE_APP_ID=provided-app-id` to environment file

**Implementation Example:**
```javascript
// Before user provides App ID
const APP_ID = import.meta.env.VITE_APP_ID || "fallback-app-id";

// After user provides App ID (e.g., "abc123def456")
const APP_ID = import.meta.env.VITE_APP_ID || "abc123def456";
```

**Critical Implementation Rules:**
- **MUST PRESERVE**: Never remove or modify the `import.meta.env` syntax
- **ONLY REPLACE**: The placeholder string "your-application-id" with user-provided App ID
- **ENVIRONMENT PRIORITY**: Environment variables always take precedence over hardcoded values
- **NON-INTRUSIVE**: Works alongside existing API patterns without overriding them

#### ⚠️ CRITICAL: Database-Driven Authentication (MANDATORY)

**AUTHENTICATION MUST USE REAL DATABASE USERS - NO HARDCODED OR MOCK DATA ALLOWED**

**Required Authentication Pattern:**
1. **Signup**: Create real users in database using Collections API (`POST /collections/users`)
2. **Signin**: Validate against real database users using Collections API (`GET /collections/users`)
3. **Password Hashing**: Use MD5 hashing with crypto-js library
4. **Email Authentication**: Use email field for user identification (not username)
5. **Database Validation**: All authentication must validate against real database records

**PROHIBITED PATTERNS:**
- ❌ Hardcoded user credentials in code
- ❌ Mock authentication responses
- ❌ Local storage user validation
- ❌ Static user data arrays
- ❌ Fake JWT tokens
- ❌ Simulated database responses

**REQUIRED PATTERNS:**
- ✅ Real database user validation
- ✅ MD5 password hashing with crypto-js
- ✅ Collections API for user operations
- ✅ Real JWT token generation
- ✅ Database-driven role management
- ✅ Session persistence with real tokens

#### ⚠️ CRITICAL: Password Hashing with Schema Transform (MANDATORY)

**SCHEMA BEHAVIOR**: When schema has `transform: "md5"`, the database automatically hashes the password once.

**FRONTEND REQUIREMENT**: Hash password once with MD5 before sending to database.

**Implementation Pattern:**
```javascript
// ✅ CORRECT: Single MD5 hash (schema will apply transform:md5)
const { MD5 } = await import('crypto-js');
const hashedPassword = MD5(password).toString();

// Send to database - schema will apply transform:md5 automatically
const user = await createObject('users', {
  email: email,
  password: hashedPassword, // Single MD5 hash
  // ... other fields
});
```

**CRITICAL RULES:**
- ✅ Frontend: Single MD5 hash
- ✅ Schema: transform: "md5" (automatic)
- ✅ Database: Stores single MD5 hash (after schema transform)
- ✅ Validation: Compare single MD5 hash with stored single MD5 hash

#### ⚠️ CRITICAL: Master Key Integration (MANDATORY)

**PROBLEM**: REST API returns empty arrays without proper authentication.

**SOLUTION**: Use master key for API access when App ID alone is insufficient.

**Implementation Pattern:**
```javascript
// Add master key support to API client
const MASTER_KEY = import.meta.env.VITE_MASTER_KEY;

// Include master key in headers when available
if (MASTER_KEY) {
  headers.set("X-Master-Key", MASTER_KEY);
}
```

**Environment Setup:**
```bash
# .env file
VITE_APP_ID=your-app-id
VITE_MASTER_KEY=your-master-key
```

**Critical Rules:**
- ✅ Master key should be stored in environment variables
- ✅ Never hardcode master key in source code
- ✅ Use .env.example for documentation
- ✅ Update .gitignore to exclude .env files

#### ⚠️ CRITICAL: Environment Variables Setup (MANDATORY)

**Required Environment Variables:**
```bash
# .env file
VITE_APP_ID=your-app-id-here
VITE_MASTER_KEY=your-master-key-here
```

**Setup Process:**
1. **Create .env file** in project root
2. **Add environment variables** with actual values
3. **Create .env.example** template file
4. **Update .gitignore** to exclude .env files
5. **Update API client** to read from environment variables

**Implementation Pattern:**
```javascript
// api.js
const API_BASE = "https://api.innque.com/v1";
const APP_ID = import.meta.env.VITE_APP_ID || "fallback-app-id";
const MASTER_KEY = import.meta.env.VITE_MASTER_KEY;
```

**Security Rules:**
- ✅ Never commit .env files to version control
- ✅ Use .env.example for documentation
- ✅ Environment variables take precedence over hardcoded values
- ✅ Provide fallback values for required variables

#### ⚠️ CRITICAL: Session Implementation (MANDATORY)

**Session Management Requirements:**
1. **JWT Token Storage**: Secure cookie-based token storage with proper expiration
2. **Session Persistence**: Users stay logged in across browser refresh/restart
3. **Automatic Logout**: Token expiration handling with automatic logout
4. **Session Validation**: Real-time session validation on protected routes
5. **Cross-Tab Synchronization**: Session state synchronized across browser tabs

**Session Implementation Pattern:**
```javascript
// Session Management in AppContext
const AppProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Check for existing session on app load
  useEffect(() => {
    const checkSession = async () => {
      try {
        console.log('🔍 Checking session on app load...');
        const token = apiClient.getToken();
        console.log('🎫 Token found:', token ? 'Yes' : 'No');
        
        if (token) {
          // Check if token is expired
          try {
            const tokenData = JSON.parse(atob(token));
            console.log('🔐 Token data:', tokenData);
            const isExpired = tokenData.exp && tokenData.exp < Date.now();
            console.log('⏰ Token expired:', isExpired);
            console.log('⏰ Current time:', Date.now());
            console.log('⏰ Token exp time:', tokenData.exp);
            
            if (isExpired) {
              console.log('❌ Token expired, clearing session');
              apiClient.clearToken();
              localStorage.removeItem('user');
              setUser(null);
            } else {
              // Token is valid, restore user session
              const userData = JSON.parse(localStorage.getItem('user') || 'null');
              console.log('👤 User data from localStorage:', userData);
              if (userData) {
                setUser(userData);
                console.log('✅ Session restored for user:', userData.email);
              } else {
                console.log('❌ No user data found, clearing session');
                apiClient.clearToken();
                setUser(null);
              }
            }
          } catch (tokenError) {
            console.log('❌ Invalid token format, clearing session:', tokenError);
            apiClient.clearToken();
            localStorage.removeItem('user');
            setUser(null);
          }
        } else {
          // No token, ensure clean state
          console.log('ℹ️ No token found, user not logged in');
          setUser(null);
        }
      } catch (error) {
        console.log('❌ Session check failed, clearing session:', error);
        apiClient.clearToken();
        localStorage.removeItem('user');
        setUser(null);
      } finally {
        setIsLoading(false);
      }
    };

    checkSession();
  }, []);

  // Session validation on route changes
  const validateSession = useCallback(async () => {
    const token = getToken();
    if (!token) {
      setUser(null);
      return false;
    }

    try {
      const currentUser = await getCurrentUser();
      if (currentUser) {
        setUser(currentUser);
        return true;
      } else {
        clearToken();
        setUser(null);
        return false;
      }
    } catch (error) {
      console.error('Session validation failed:', error);
      clearToken();
      setUser(null);
      return false;
    }
  }, []);

  // Clear session when user logs out
  const logout = () => {
    console.log('🚪 User logging out');
    apiClient.clearToken();
    localStorage.removeItem('user');
    setUser(null);
  };

  const value = {
    user,
    setUser,
    schemas,
    setSchemas,
    isLoading,
    logout,
  };
  
  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
};
```

**Protected Route Implementation:**
```javascript
// ProtectedRoute with session validation
const ProtectedRoute = ({ children }) => {
  const { user, loading, validateSession } = useApp();
  const location = useLocation();
  const [isValidating, setIsValidating] = useState(false);

  useEffect(() => {
    const checkAuth = async () => {
      if (!user && !loading) {
        setIsValidating(true);
        const isValid = await validateSession();
        setIsValidating(false);
        
        if (!isValid) {
          // Redirect to signin with return path
          navigate('/signin', { 
            state: { from: location },
            replace: true 
          });
        }
      }
    };

    checkAuth();
  }, [user, loading, validateSession, location]);

  if (loading || isValidating) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"></div>
      </div>
    );
  }

  return user ? children : null;
};
```

**Session Security Rules:**
- ✅ JWT tokens stored in secure HTTP-only cookies
- ✅ Token expiration handled gracefully
- ✅ Automatic logout on token expiration
- ✅ Session validation on every protected route access
- ✅ Cross-tab session synchronization
- ✅ Secure token cleanup on logout

#### ⚠️ CRITICAL: Real-time Database Validation (MANDATORY)

**REALTIME MEANS: EVERY LOGIN ATTEMPT QUERIES DATABASE DIRECTLY - NO CACHING OR HARDCODING**

**Prohibited Patterns (NEVER DO THIS):**
```javascript
// ❌ WRONG: Get users from database once, then hardcode them
const users = await getUsersFromDatabase(); // Get once
const hardcodedUsers = users; // Hardcode the list
if (hardcodedUsers.find(u => u.email === email)) { // Check against hardcoded list
  // This is NOT realtime!
}

// ❌ WRONG: Cache users in memory or localStorage
const cachedUsers = localStorage.getItem('users'); // Cached data
if (cachedUsers.includes(email)) { // Check against cache
  // This is NOT realtime!
}
```

**Required Real-time Pattern (ALWAYS DO THIS):**
```javascript
// ✅ CORRECT: Complete login implementation with all required features
export async function signIn({ email, password }, options) {
  // Clear any existing token before signin
  clearToken();
  
  // Hash password with MD5 (single hash - schema will apply transform:md5)
  const { MD5 } = await import('crypto-js');
  const hashedPassword = MD5(password).toString();
  
  // Query database in real-time for this specific user using Innque API
  const users = await apiClient.findObjects('users', { email: email });
  
  // Validate against real-time database result
  if (users && users.length > 0) {
    const user = users[0];
    
    // Check if user is active
    if (user.status !== 'active') {
      throw new Error('Account is inactive. Please contact support.');
    }
    
    // Validate password (compare single MD5 hash with stored single MD5 hash)
    if (user.password === hashedPassword) {
      // Get role information
      let role = null;
      if (user.roles && user.roles.length > 0) {
        const roleId = user.roles[0].id;
        const roles = await request(`/collections/roles?where={"id":"${roleId}"}`, {
          method: "GET",
          headers: {
            "X-Application-Id": APP_ID,
            "X-Master-Key": MASTER_KEY
          }
        });
        role = roles[0] || null;
      }
      
      // Create JWT token
      const token = btoa(JSON.stringify({
        userId: user.id,
        email: user.email,
        role: role?.name || 'user',
        exp: Date.now() + (24 * 60 * 60 * 1000) // 24 hours
      }));
      
      // Store token and user data
      saveToken(token);
      localStorage.setItem('user', JSON.stringify({ ...user, role }));
      
      return { success: true, user, token };
    } else {
      throw new Error('Invalid password. Please check your password and try again.');
    }
  } else {
    throw new Error('User not found. Please check your email address and try again.');
  }
}
```

#### ⚠️ CRITICAL: Innque Database Operations (MANDATORY)

**Innque API Endpoints for Real-time Database Operations:**

**1. Find User by Email (Real-time Login):**
```javascript
// ✅ CORRECT: Real-time user lookup for login
const findUserByEmail = async (email) => {
  const response = await request(`/collections/users?where={"email":"${email}"}`, {
    method: "GET",
    headers: {
      "X-Application-Id": APP_ID
    }
  });
  return response;
};
```

**2. Create New User (Real-time Signup):**
```javascript
// ✅ CORRECT: Real-time user creation for signup
const createUser = async (userData) => {
  const { MD5 } = await import('crypto-js');
  const hashedPassword = MD5(userData.password).toString();
  
  const newUser = {
    email: userData.email,
    username: userData.username,
    password: hashedPassword,
    firstName: userData.firstName,
    lastName: userData.lastName,
    status: "active"
  };
  
  const response = await request(`/collections/users`, {
    method: "POST",
    body: newUser,
    headers: {
      "X-Application-Id": APP_ID,
      "Content-Type": "application/json"
    }
  });
  return response;
};
```

**3. Get All Users (Real-time Data Display):**
```javascript
// ✅ CORRECT: Real-time user list for admin pages
const getAllUsers = async () => {
  const response = await request(`/collections/users`, {
    method: "GET",
    headers: {
      "X-Application-Id": APP_ID
    }
  });
  return response;
};
```

**4. Update User (Real-time User Management):**
```javascript
// ✅ CORRECT: Real-time user update
const updateUser = async (userId, updateData) => {
  const response = await request(`/collections/users/${userId}`, {
    method: "PUT",
    body: updateData,
    headers: {
      "X-Application-Id": APP_ID,
      "Content-Type": "application/json"
    }
  });
  return response;
};
```

**5. Delete User (Real-time User Management):**
```javascript
// ✅ CORRECT: Real-time user deletion
const deleteUser = async (userId) => {
  const response = await request(`/collections/users/${userId}`, {
    method: "DELETE",
    headers: {
      "X-Application-Id": APP_ID
    }
  });
  return response;
};
```

**Real-time Validation Requirements:**
- **Every login attempt** must query database directly
- **No hardcoded user lists** allowed
- **No cached user data** allowed
- **No localStorage user data** allowed
- **Direct database query** for each authentication attempt
- **Fresh data** from database every time

#### ⚠️ CRITICAL: Login Troubleshooting Guide (MANDATORY)

**Common Login Issues and Solutions:**

**1. API Returns Empty Arrays**
- **Problem**: `GET /collections/users` returns `[]` despite users existing
- **Solution**: Add master key to API headers
- **Code**: `headers.set("X-Master-Key", MASTER_KEY)`

**2. Password Validation Fails**
- **Problem**: Correct password shows "Invalid credentials"
- **Solution**: Use single MD5 hash (schema applies transform:md5)
- **Code**: `const hashedPassword = MD5(password).toString()`

**3. Authorization Header Errors**
- **Problem**: 400 Bad Request on signin/signup
- **Solution**: Exclude auth headers for authentication endpoints
- **Code**: `if (token && !path.includes('/signin') && !path.includes('/signup'))`

**4. Duplicate Key Errors**
- **Problem**: "E11000 duplicate key error" when updating users
- **Solution**: Mark ID fields as immutable in schema
- **Code**: `"immutable": true` in schema definition

**5. Token Contamination**
- **Problem**: Login fails due to existing invalid tokens
- **Solution**: Clear tokens before signin
- **Code**: `clearToken()` before authentication

**6. Role Access Issues**
- **Problem**: User has no role or role is null
- **Solution**: Check user.roles array and fetch role details
- **Code**: `const roleId = user.roles[0].id`

**Debugging Checklist:**
- ✅ Check API headers include X-Application-Id and X-Master-Key
- ✅ Verify password hashing matches schema transform
- ✅ Ensure no authorization headers for signin/signup
- ✅ Clear existing tokens before authentication
- ✅ Check user status is 'active'
- ✅ Verify role information is properly fetched
- ✅ Test with fresh browser session

#### ⚠️ CRITICAL: Specific Error Messages (MANDATORY)

**PROBLEM**: Generic "Invalid email or password" doesn't help users understand the issue.

**SOLUTION**: Provide specific error messages for different scenarios.

**Implementation Pattern:**
```javascript
// ✅ CORRECT: Specific error messages for different scenarios
export async function signIn({ email, password }, options) {
  // Clear any existing token before signin
  clearToken();
  
  // Hash password with MD5 (single hash - schema will apply transform:md5)
  const { MD5 } = await import('crypto-js');
  const hashedPassword = MD5(password).toString();
  
  // Query database in real-time for this specific user using Innque API
  const users = await apiClient.findObjects('users', { email: email });
  
  // Validate against real-time database result
  if (users && users.length > 0) {
    const user = users[0];
    
    // Check if user is active
    if (user.status !== 'active') {
      throw new Error('Account is inactive. Please contact support.');
    }
    
    // Validate password (compare single MD5 hash with stored single MD5 hash)
    if (user.password === hashedPassword) {
      // ... success logic
      return { success: true, user, token };
    } else {
      throw new Error('Invalid email or password');
    }
  } else {
    throw new Error('User not found.');
  }
}
```

**Error Message Types:**
1. **User Not Found**: "User not found. Please check your email address and try again."
2. **Invalid Credentials**: "Invalid email or password" (when user exists but password is wrong - for security)
3. **Account Inactive**: "Account is inactive. Please contact support."
4. **Network Error**: "Network error. Please check your connection and try again."
5. **Server Error**: "Server error. Please try again later."

**Security Considerations:**
- ✅ **User Not Found**: Show when email doesn't exist in database
- ✅ **Invalid Credentials**: Show when user exists but password is wrong (prevents email enumeration)
- ✅ **Account Status**: Show specific status messages (inactive, suspended, etc.)
- ✅ **Network Issues**: Show connection-related errors

**Critical Rules:**
- ✅ Use "User not found" only when email doesn't exist in database
- ✅ Use "Invalid email or password" when user exists but password is wrong (security)
- ✅ Provide specific guidance for each error type
- ✅ Help users understand what went wrong
- ✅ Suggest specific actions to resolve the issue

#### ⚠️ Critical Authentication Issue: Authorization Headers in Signin/Signup

**PROBLEM**: Sending `Authorization: Bearer {token}` headers with signin/signup requests causes 400 Bad Request errors.

**ROOT CAUSE**: The API client automatically adds authorization headers when a JWT token exists, but signin/signup requests should NOT include authorization headers since the user is not yet authenticated.

**SOLUTION**: Modify the API client to exclude authorization headers for authentication endpoints:

```javascript
// ❌ WRONG - Sends authorization header with signin
const token = getToken();
if (token) {
  headers.set("Authorization", `Bearer ${token}`);
} else {
  headers.set("X-Application-Id", APP_ID);
}

// ✅ CORRECT - Exclude authorization for signin/signup
const token = getToken();
if (token && !path.includes('/signin') && !path.includes('/signup')) {
  headers.set("Authorization", `Bearer ${token}`);
} else {
  headers.set("X-Application-Id", APP_ID);
}
```

**ADDITIONAL FIX**: Clear existing tokens before signin to ensure fresh authentication:

```javascript
// Clear any existing token before signin
clearToken();
```

**SYMPTOMS**: 
- 400 Bad Request errors on signin/signup requests
- Console shows "API Error: 400 for POST /signin"
- Request headers include `authorization: 'Bearer ...'` for signin requests

**PREVENTION**: Always test authentication flows with fresh browser sessions to catch token contamination issues.

#### ⚠️ CRITICAL: Schema Field Immutability (MANDATORY)

**PROBLEM**: Duplicate key errors when updating objects with ID fields.

**SOLUTION**: Mark ID fields as immutable to prevent modification during updates.

**Implementation Pattern:**
```javascript
// Schema definition with immutable ID field
{
  "id": {
    "type": "String",
    "default": "${crypto.uuid}",
    "required": true,
    "setOnInsert": true,
    "unique": true,
    "immutable": true  // Prevents modification during updates
  }
}
```

**Critical Rules:**
- ✅ ID fields must be immutable
- ✅ Use setOnInsert: true for ID fields
- ✅ Never include ID in update operations
- ✅ Test update operations to ensure no duplicate key errors

### Error Handling & Resilience

- Implement comprehensive error handling patterns
- Design retry mechanisms with exponential backoff
- Handle network timeouts and connection failures
- Provide graceful degradation and recovery strategies

---

## 🏗 API Architecture

### Base Configuration

#### API Base URL

```
https://api.innque.com/v1
```

#### Required Headers

```
Content-Type: application/json
```

#### Optional Headers

```
X-Application-Id: your-application-id  // Will be replaced with actual App ID from prompt
```

#### Authentication Headers

```
Authorization: Bearer {jwt_token}  // For user-specific operations
X-Master-Key: your-master-key      // For debugging only - bypasses security
```

---

## 📦 API Endpoints Reference

### Collections API

#### Create Object

```
POST /collections/{collection_name}
Body: {object_data}
```

#### Get All Objects

```
GET /collections/{collection_name}
Query Parameters:
  - where: JSON string (filtering conditions)
  - limit: number (max results)
  - skip: number (pagination offset)
  - sort: JSON string (sorting criteria)
  - includes: JSON string (array of related object names)
  - keys: JSON string (array of field names to include)
```

#### Query Parameters Reference

##### Filtering (where parameter)

```json
// Simple equality
{"name": "sugar"}

// Range queries
{"price": {"$gt": 10, "$lt": 100}}
// Array operations
{"category": {"$in": ["Electronics", "Books"]}}
// Complex queries
{
  "$and": [
    {"price": {"$gte": 50}},
    {"category": "Electronics"},
    {"isActive": true}
  ]
}
```

##### Sorting (sort parameter)

```json
{
  "created": -1, // Descending
  "name": 1 // Ascending
}
```

#### Get Object by ID

```
GET /collections/{collection_name}/{object_id}
```

#### Update Object

```
PUT /collections/{collection_name}/{object_id}
Body: {updated_object_data}
```

#### Delete Object

```
DELETE /collections/{collection_name}/{object_id}
```

#### Count Objects

```
GET /count/{collection_name}
Query Parameters:
  - where: JSON string (filtering conditions)
Response:
{
  "count": 10
}
```

### Users API

#### Sign Up

```
POST /collections/users
Body: {
  "email": "string",
  "username": "string", 
  "password": "string", // MD5 hashed
  "firstName": "string",
  "lastName": "string",
  "status": "active"
}
```

#### Sign In

```
POST /signin
Body: {
  "email": "string",
  "password": "string"
}
```

**Note**: Signin uses Collections API to find user by email, then validates password against database.

#### Get Current User

```
GET /me
Authorization: Bearer {jwt_token}
```

#### Sign Out

```
POST /signout
Authorization: Bearer {jwt_token}
```

### Files API

#### Upload File

```
POST /files/{filename}
Content-Type: {file_content_type}
Body: {file_blob}
```

#### Download File

```
GET /files/{application-id}/{filename}
```

### Schemas API

#### Create Schema

```
POST /schemas
Body: {schema_definition}
```

#### Get Schema

```
GET /schemas/{schema_name}
```

#### Get All Schemas

```
GET /schemas
Query Parameters:
  - where: JSON string (filtering conditions)
```

#### Update Schema

```
PUT /schemas/{schema_name}
Body: {updated_schema_definition}
```

#### Delete Schema

```
DELETE /schemas/{schema_name}
```

---

## 🚨 Error Response Codes

- **400**: Bad Request - Invalid request data
- **401**: Unauthorized - Missing or invalid authentication
- **403**: Forbidden - Insufficient permissions
- **404**: Not Found - Resource doesn't exist
- **500**: Internal Server Error - Server error

---

## 🔧 Implementation Patterns

### Complete API Client Implementation (MANDATORY)

**Required Features:**
1. **JWT Token Management**: Cookie-based token storage
2. **Retry Mechanism**: Exponential backoff for failed requests
3. **Timeout Handling**: Request timeout with configurable duration
4. **Master Key Support**: For API access when needed
5. **Authorization Header Logic**: Exclude auth headers for signin/signup
6. **Error Handling**: Comprehensive error handling with retry logic

### Modern API Client Implementation

```javascript
// api.js

const API_BASE = "https://api.innque.com/v1";
const APP_ID = import.meta.env.VITE_APP_ID || "fallback-app-id"; // Will be replaced with actual App ID from prompt
const MASTER_KEY = import.meta.env.VITE_MASTER_KEY; // Master key for API access
const DEFAULT_RETRIES = 3; // Number of retry attempts

// —————— Native Cookie Helpers ——————
function setCookie(name, value, days = 365) {
  const expires = new Date(Date.now() + days * 864e5).toUTCString();
  document.cookie = [
    `${encodeURIComponent(name)}=${encodeURIComponent(value)}`,
    `expires=${expires}`,
    `path=/`,
    `Secure`, // send only over HTTPS
    `SameSite=Strict`, // adjust: Lax or None as needed
  ].join("; ");
}
function getCookie(name) {
  return document.cookie.split("; ").reduce((value, pair) => {
    const [key, val] = pair.split("=");
    return decodeURIComponent(key) === name ? decodeURIComponent(val) : value;
  }, null);
}
function deleteCookie(name) {
  document.cookie = `${encodeURIComponent(name)}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
}

// —————— JWT Helpers ——————
function saveToken(token) {
  setCookie("jwt", token); // defaults to 365 days
}
function getToken() {
  return getCookie("jwt");
}
function clearToken() {
  deleteCookie("jwt");
}
// —————— Utility: Delay for backoff ——————
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
// —————— Core Fetch Wrapper with Retry ——————
async function request(path, { method = "GET", body = null, headers: customHeaders, retries = DEFAULT_RETRIES, timeout = 30000, signal } = {}) {
  const url = `${API_BASE}${path}`;
  // Recursive dispatch function
  async function dispatch(attempt) {
    const headers = new Headers(customHeaders);
    // Only set default Content-Type if not already set and body is not a Blob
    if (!headers.has("Content-Type") && !(body instanceof Blob)) {
      headers.set("Content-Type", "application/json");
    }
    const token = getToken();
    // Don't send authorization header for signin/signup requests
    if (token && !path.includes('/signin') && !path.includes('/signup')) {
      headers.set("Authorization", `Bearer ${token}`);
    } else {
      headers.set("X-Application-Id", APP_ID);
    }
    if (MASTER_KEY) {
      headers.set("X-Master-Key", MASTER_KEY);
    }
    const opts = { method, headers };
    if (body != null) {
      // Only stringify if it's not already a string or Blob
      opts.body = body instanceof Blob || typeof body === "string" ? body : JSON.stringify(body);
    }
    if (signal) {
      opts.signal = signal;
    }
    try {
      // Create timeout promise
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error(`Request timeout after ${timeout}ms`)), timeout);
      });
      // Create fetch promise
      const fetchPromise = fetch(url, opts);
      // Race between fetch and timeout
      const res = await Promise.race([fetchPromise, timeoutPromise]);
      // Retry on 5xx
      if (res.status >= 500 && attempt < retries) {
        const backoff = Math.pow(2, attempt) * 200 + Math.random() * 100;
        await delay(backoff);
        return dispatch(attempt + 1);
      }
      if (!res.ok) {
        const errBody = await res.json().catch(() => ({}));
        if (errBody.message === "Invalid session token") {
          clearToken();
        }
        throw new Error(errBody.message || `${res.status} ${res.statusText}`);
      }
      return res.status === 204 ? null : res.json();
    } catch (err) {
      // Retry on timeout or network errors
      if ((err instanceof TypeError || /network/i.test(err.message) || /timeout/i.test(err.message)) && attempt < retries) {
        const backoff = Math.pow(2, attempt) * 200 + Math.random() * 100;
        await delay(backoff);
        return dispatch(attempt + 1);
      }
      throw err;
    }
  }
  return dispatch(0);
}

// —————— API Client Class ——————
class APIClient {
  constructor() {
    this.baseURL = API_BASE;
    this.appId = APP_ID;
  }

  // Generic request method with error handling
  async request(endpoint, options = {}) {
    return request(endpoint, options);
  }

  // GET request
  async get(endpoint, params = {}) {
    const queryString = new URLSearchParams(params).toString();
    const url = queryString ? `${endpoint}?${queryString}` : endpoint;
    return this.request(url, { method: 'GET' });
  }

  // POST request
  async post(endpoint, data = {}) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  // PUT request
  async put(endpoint, data = {}) {
    return this.request(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  // DELETE request
  async delete(endpoint) {
    return this.request(endpoint, { method: 'DELETE' });
  }

  // Collections API methods
  async findObjects(collection, where = {}, options = {}) {
    console.log('🔍 FIND OBJECTS:', {
      collection: collection,
      where: where,
      options: options
    });
    
    // Build query parameters
    const queryParams = new URLSearchParams();
    if (where && Object.keys(where).length > 0) {
      queryParams.set('where', JSON.stringify(where));
    }
    if (options.limit) {
      queryParams.set('limit', options.limit);
    }
    if (options.skip) {
      queryParams.set('skip', options.skip);
    }
    if (options.sort) {
      queryParams.set('sort', JSON.stringify(options.sort));
    }
    
    const queryString = queryParams.toString();
    const path = queryString ? `/collections/${collection}?${queryString}` : `/collections/${collection}`;
    
    console.log('📋 QUERY PATH:', path);
    
    const result = await this.request(path, { method: 'GET' });
    console.log('📊 FIND RESULT:', result);
    
    return result;
  }

  async getObject(collection, objectId) {
    return this.get(`/collections/${collection}/${objectId}`);
  }

  async createObject(collection, data) {
    return this.post(`/collections/${collection}`, data);
  }

  async updateObject(collection, objectId, data) {
    return this.put(`/collections/${collection}/${objectId}`, data);
  }

  async deleteObject(collection, objectId) {
    return this.delete(`/collections/${collection}/${objectId}`);
  }

  async countObjects(collection, where = {}) {
    const params = { where: JSON.stringify(where), count: true };
    return this.get(`/collections/${collection}`, params);
  }

  // JWT token management methods
  saveToken(token) {
    saveToken(token);
  }

  getToken() {
    return getToken();
  }

  clearToken() {
    clearToken();
  }
}

// Create singleton instance
const apiClient = new APIClient();

// Export both the client and individual functions for flexibility
export default apiClient;
export { saveToken, getToken, clearToken };

// —————— Collections API (Individual Functions) ——————
export const createObject = (collection, data, options) => {
  if (!collection) throw new Error("Collection name is required");
  if (!data || typeof data !== "object") throw new Error("Data must be an object");
  return request(`/collections/${collection}`, { method: "POST", body: data, ...options });
};
export const findObjects = (collection, { where, limit, skip, sort, includes, keys } = {}, options) => {
  const qp = new URLSearchParams();
  if (where) qp.set("where", JSON.stringify(where));
  if (limit) qp.set("limit", limit);
  if (skip) qp.set("skip", skip);
  if (sort) qp.set("sort", JSON.stringify(sort));
  if (includes) qp.set("includes", JSON.stringify(includes));
  if (keys) qp.set("keys", JSON.stringify(keys));
  return request(`/collections/${collection}?${qp.toString()}`, options);
};
export const getObject = (collection, id, options) => request(`/collections/${collection}/${id}`, options);
export const updateObject = (collection, data, options) => request(`/collections/${collection}/${data.id}`, { method: "PUT", body: data, ...options });
export const deleteObject = (collection, id, options) => request(`/collections/${collection}/${id}`, { method: "DELETE", ...options });
export const countObjects = (collection, where, options) => {
  const qp = where ? `?where=${encodeURIComponent(JSON.stringify(where))}` : "";
  return request(`/count/${collection}${qp}`, options);
};

// —————— Users API ——————
export async function signUp({ email, password, firstName, lastName, username }, options) {
  // Hash password with MD5 before sending to database
  const { MD5 } = await import('crypto-js');
  const hashedPassword = MD5(password).toString();
  
  // Create user in database using Collections API
  const newUser = await createObject('users', {
    email: email,
    username: username,
    password: hashedPassword, // MD5 hashed
    firstName: firstName,
    lastName: lastName,
    status: 'active'
  }, options);
  
  if (newUser.token) saveToken(newUser.token);
  return newUser;
}

// Note: Use the real-time database signIn function shown above (line 119)
export async function signOut(options) {
  try {
    await request("/signout", { method: "POST", ...options });
  } catch (error) {
    console.error(error.message);
  } finally {
    clearToken();
  }
}
export const getCurrentUser = (options) => request("/me", options);

// —————— Files API ——————
export async function uploadFile(file, filename = file.name, options) {
  // Convert file to blob if it's not already
  const blob = file instanceof Blob ? file : new Blob([file], { type: file.type });
  const headers = new Headers();
  headers.set("Content-Type", blob.type || "application/octet-stream");
  return request(`/files/${filename}`, {
    method: "POST",
    body: blob,
    headers,
    ...options,
  });
}
// —————— Schemas API ——————
export const createSchema = (schema, options) => request("/schemas", { method: "POST", body: schema, ...options });
export const getSchema = (collection, options) => request(`/schemas/${collection}`, options);
export const getSchemas = (where, options) => {
  const qp = where ? `?where=${encodeURIComponent(JSON.stringify(where))}` : "";
  return request(`/schemas${qp}`, options);
};
export const updateSchema = (schema, options) => request(`/schemas/${schema.collection}`, { method: "PUT", body: schema, ...options });
export const deleteSchema = (collection, options) => request(`/schemas/${collection}`, { method: "DELETE", ...options });
```

### React Hook Pattern Implementation

#### Object Hooks

```javascript
import { useState, useCallback, useRef } from "react";
import { createObject } from "../../api.js";
export function useCreateObject() {
  const [object, setObject] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const abortControllerRef = useRef(null);

  const create = useCallback(async (collection, object, options = {}) => {
    setLoading(true);
    setError(null);
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();
    try {
      const response = await createObject(collection, object, {
        signal: abortControllerRef.current.signal,
        ...options,
      });
      setObject(response);
      return response;
    } catch (err) {
      if (err.name === "AbortError") {
        console.log("Create object hook was aborted");
        return null;
      }
      const errorMessage = `Create object failed: ${err.message}`;
      setError(new Error(errorMessage));
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
      abortControllerRef.current = null;
    }
  }, []);
  const abort = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
  }, []);
  return {
    create,
    object,
    loading,
    error,
    abort
  };
}
```

#### Upsert Object Hook

```javascript
    try {
      let response;
      // Check if this is an update (has id) or create (no id)
      if (object && object.id) {
        // Update existing object
        response = await updateObject(collection, object, {
          signal: abortControllerRef.current.signal,
          upsert: true,
          ...options,
        });
      } else {
        // Create new object
        response = await createObject(collection, object, {
          signal: abortControllerRef.current.signal,
          ...options,
        });
      }
      setObject(response);
      return response;
    }
```

### Directory Structure

```
src/
├── api.js   # Core API client with authentication and request handling
└── usecases/
    ├── object/
    │   ├── useCreateObject.js
    │   ├── useGetObject.js
    │   ├── useUpdateObject.js
    │   ├── useDeleteObject.js
    │   ├── useFindObjects.js
    │   ├── useUpsertObject.js
    │   └── useCountObjects.js
    ├── schema/
    │   ├── useCreateSchema.js
    │   ├── useGetSchema.js
    │   ├── useFindSchemas.js
    │   ├── useUpdateSchema.js
    │   └── useDeleteSchema.js
    ├── user/
    │   ├── useSignUp.js
    │   ├── useSignIn.js
    │   ├── useSignOut.js
    │   └── useGetCurrentUser.js
    └── file/
        └── useUploadFile.js
```

**MainPage Initialization**: MainPage is responsible for initializing schemas and current user data when the application starts. This ensures all components have access to the necessary data through AppContext.

**Schema Reuse Pattern**: Always get schemas from AppContext instead of individual API calls to ensure consistency across the entire application and avoid duplicate network requests.


```javascript
  const { schemas } = useContext(AppContext);
  const schema = schemas.find(s => s.name === collection);
```


```javascript
//src/pages/ProtectedRoute.jsx
const ProtectedRoute = ({ children }) => {
  const location = useLocation();
  const [loading, setLoading] = useState(true);
  const { user, setUser, setSchemas } = useContext(AppContext);
  const { find: findSchemas } = useFindSchemas();

  const checkAuth = useCallback(async () => {
    try {
      if (!user) {
        const fetchedUser = await getCurrentUser();
        if (fetchedUser) {
          setUser(fetchedUser);
          // Load schemas after user is authenticated
          const schemas = await findSchemas({});
          if (schemas) setSchemas(schemas);
        }
      } else {
        // If user already exists, just load schemas
        const schemas = await findSchemas({});
        if (schemas) setSchemas(schemas);
      }
      setLoading(false);
    } catch (error) {
      console.error('Authentication check failed:', error);
      setLoading(false);
    }
  }, [user, setUser, findSchemas, setSchemas]);

  useEffect(() => {
    checkAuth();
  }, [checkAuth]);

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Spinner size="lg" />
      </div>
    );
  }

  return user ? (
    children
  ) : (
    <Navigate to="/signin" state={{ from: location }} replace />
  );
};
```
```javascript
//src/App.jsx
<Route path="/*" element={<ProtectedRoute><MainPage /></ProtectedRoute>} />
```